<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lean Menu - Elite Edition</title> 
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="style.css">

</head>
<body>
    <div class="menu-wrapper">
                    <div class="external-scrollbar">
                <div class="scroll-arrow scroll-arrow-up">▲</div>
                <div class="custom-scrollbar">
                    <div class="custom-scrollbar-thumb" id="customScrollbarThumb"></div>
                    <div class="scrollbar-indicator" id="scrollbarIndicator"></div>
                </div>
                <div class="scroll-arrow scroll-arrow-down">▼</div>
            </div>
        
        <div class="menu-container" id="mainMenu">
            <div class="menu-header" id="menuHeader"></div>
            
            <!-- Tab Headers -->
            <div class="tab-container" id="tabContainer" style="display: none;">
                <div class="tab-headers" id="tabHeaders">
                    <!-- Tab headers will be dynamically generated -->
                </div>
            </div>

            <div class="menu-items" id="menuItemsContainer">
                <div class="highlight-bar"></div> 
            </div>

            <div class="menu-footer">
                <span class="version">Version: Beta | build: 4 | 24hrs ago | Created By luabyff</span>
                <span class="counter" id="counter">1/9</span> 
            </div>
        </div>
    </div>

    <div class="notification-container" id="notificationContainer">
    </div>

    <div class="spectators-container" id="spectatorsContainer" style="display: none;">
        <div class="spectators-header">
            <div class="spectators-icon">
                <i class="fa-solid fa-eye"></i>
            </div>
            <div class="spectators-title">Spectators List</div>
        </div>
        <div class="spectators-separator"></div>
        <div class="spectators-list" id="spectatorsList">
            </div>
    </div>

    <div class="tooltip-container" id="tooltipContainer" style="display: none;">
        <div class="tooltip-content" id="tooltipContent">
            </div>
    </div>

    <div class="key-binding-overlay" id="keyBindingOverlay" style="display: none;">
        <div class="keybind-container">
            <div class="header">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="icon">
                    <path d="M11.996 2.01c-5.522 0-9.998 4.477-9.998 9.998s4.476 9.998 9.998 9.998 9.998-4.477 9.998-9.998-4.476-9.998-9.998-9.998zm-4.321 15.657l-1.01-1.01 2.222-2.223 1.01 1.01-2.222 2.223zm6.666 0l-1.01-1.01 2.222-2.223 1.01 1.01-2.222 2.223zm-4.444-4.444l-1.01-1.01 2.222-2.223 1.01 1.01-2.222 2.223zm6.666 0l-1.01-1.01 2.222-2.223 1.01 1.01-2.222 2.223z"/>
                </svg>
                <span class="label">Select a keybind (Open key)</span>
            </div>
            <div class="input-field" id="keyBindingInput">
                <span class="key-text" id="keyBindingText"></span>
                <span class="cursor" id="cursor"></span>
            </div>
        </div>
    </div>

    <script>
        const bannerImageUrl = 'default.png'; // Default Homer Atlas header image 

        let currentIndex = 0; 
        let currentMenuType = 'main';

        const menuContainer = document.getElementById('mainMenu'); 
        const menuItemsContainer = document.getElementById('menuItemsContainer'); 
        let highlightBar = document.querySelector('.highlight-bar'); 
        const counterElement = document.getElementById('counter'); 
        const notificationContainer = document.getElementById('notificationContainer');

        const menuData = {
            main: {
                title: 'HOME',
                items: [
                    { name: "Self", icon: '<i class="fa-solid fa-user"></i>', desc: "Player Options", action: "self", tooltip: "Access player-specific settings and controls" },
                    { name: "Online", icon: '<i class="fa-solid fa-desktop"></i>', desc: "Online Features", action: "online", tooltip: "Manage online features and server interactions" },
                    { name: "Combat/Weapons", icon: '<i class="fa-solid fa-crosshairs"></i>', desc: "Weapon System", action: "combat", tooltip: "Configure combat settings and weapon modifications" },
                    { name: "Visual", icon: '<i class="fa-solid fa-eye"></i>', desc: "Visual Effects", action: "visual", tooltip: "Customize visual effects and graphics settings" },
                    { name: "Vehicle", icon: '<i class="fa-solid fa-car"></i>', desc: "Vehicle Menu", action: "vehicle", tooltip: "Access vehicle-related features and controls" },
                    { name: "Destructive", icon: '<i class="fa-solid fa-bomb"></i>', desc: "Destruction Tools", action: "destructive", tooltip: "Use destructive tools and demolition features" },
                    { name: "Settings", icon: '<i class="fa-solid fa-gear"></i>', desc: "System Settings", action: "settings", tooltip: "Configure system settings and preferences" }
                ]
            },
            self: {
                title: 'HOME > SELF > PLAYER SETTINGS',
                isTabbed: true,
                currentTab: 'player',
                tabs: {
                    player: {
                        title: 'Player',
                items: [
                    { name: "Noclip", action: "noclip_toggle", type: "slider", checked: false, value: 10.0, min: 10.0, max: 50.0, step: 0.1, icon: '<i class="fa-solid fa-ghost"></i>', desc: "Toggle noclip mode to move through walls and objects", tooltip: "Toggle noclip mode to move through walls and objects" },
                    { name: "Set Health", action: "set_health", type: "slider", value: 0.0, min: 0.0, max: 200.0, step: 1.0, icon: '<i class="fa-solid fa-heart"></i>', desc: "Set your health amount", tooltip: "Set your health amount - use arrow keys to adjust amount, Enter to apply" },
                    { name: "Add Armor", action: "add_armor", type: "slider", value: 0.0, min: 0.0, max: 100.0, step: 1.0, icon: '<i class="fa-solid fa-shield"></i>', desc: "Add armor to your character", tooltip: "Add armor to your character - use arrow keys to adjust amount, Enter to apply" },
                ]
                    },
                                miscellaneous: {
                title: 'Miscellaneous',
                items: [
                    { name: "TP to Waypoint", action: "tp_to_waypoint", icon: '<i class="fa-solid fa-location-arrow"></i>', desc: "Teleport to Map Waypoint", tooltip: "Instantly teleport to your set waypoint on the map" },
                    { name: "Slide Mode", action: "slide_mode", type: "slider", checked: false, value: 10.0, min: 1.0, max: 20.0, step: 0.1, icon: '<i class="fa-solid fa-person-running"></i>', desc: "Enable enhanced movement sliding", tooltip: "Activate slide mode for enhanced movement and sliding abilities" },
                    { name: "Solo Session", action: "solo_session", type: "toggle", checked: false, icon: '<i class="fa-solid fa-user"></i>', desc: "Toggle Solo Session", tooltip: "Start or stop solo session mode" },
                    { name: "Uncuff/Cuff", action: "toggle_handcuff", icon: '<i class="fa-solid fa-handcuffs"></i>', desc: "Toggle handcuff status", tooltip: "Toggle between cuffed and uncuffed state" },
                    { name: "Drag/Undrag", action: "toggle_drag", icon: '<i class="fa-solid fa-arrows-up-down-left-right"></i>', desc: "Toggle drag status", tooltip: "Toggle between drag and undrag state" },
                ]
            },
                    wardrobe: {
                        title: 'Wardrobe',
                        items: [
                            { name: "OutFits", action: "outfits", type: "combo", value: "Random", options: ["Random", "Kkk", "nwwea"], icon: '<i class="fa-solid fa-shirt"></i>', desc: "Change Player Outfit", tooltip: "Change your character's appearance with preset outfits" },
                        ]
                    }
                }
            },
            combat: {
                title: 'Combat/Weapons',
                isTabbed: true,
                currentTab: 'weapon_spawner',
                tabs: {
                    weapon_spawner: {
                        title: 'Weapon Spawner',
                        items: [
                            { name: "Give All Weapons", action: "give_all_weapons", icon: '<i class="fa-solid fa-gun"></i>', desc: "Get all weapons with max ammo", tooltip: "Request all weapons with maximum ammunition" },
                            { name: "Remove All Weapons", action: "remove_all_weapons", icon: '<i class="fa-solid fa-trash"></i>', desc: "Remove all weapons from inventory", tooltip: "Remove all weapons from your inventory" },
                            { name: "Melee Weapons", action: "spawn_melee", type: "combo", value: "Knife", options: ["Knife", "Baseball Bat", "Crowbar", "Hammer", "Hatchet", "Machete", "Switchblade", "Nightstick", "Wrench", "Battleaxe", "Pool Cue", "Stone Hatchet", "Dagger", "Bottle", "Golf Club", "Knuckle"], icon: '<i class="fa-solid fa-fist-raised"></i>', desc: "Spawn melee weapons", tooltip: "Choose and spawn a specific melee weapon" },
                            { name: "Handguns", action: "spawn_handgun", type: "combo", value: "Pistol", options: ["Pistol", "Pistol MK2", "Combat Pistol", "AP Pistol", "Stun Gun", "Pistol .50", "SNS Pistol", "SNS Pistol MK2", "Heavy Pistol", "Vintage Pistol", "Flare Gun", "Marksman Pistol", "Revolver", "Revolver MK2", "Double Action", "Ray Pistol", "Ceramic Pistol", "Navy Revolver"], icon: '<i class="fa-solid fa-gun"></i>', desc: "Spawn handguns", tooltip: "Choose and spawn a specific handgun" },
                            { name: "Rifles", action: "spawn_rifle", type: "combo", value: "Assault Rifle", options: ["Assault Rifle", "Assault Rifle MK2", "Carbine Rifle", "Carbine Rifle MK2", "Advanced Rifle", "Special Carbine", "Special Carbine MK2", "Bullpup Rifle", "Bullpup Rifle MK2", "Compact Rifle", "MG", "Combat MG", "Combat MG MK2", "Gusenberg Sweeper", "Sniper Rifle", "Heavy Sniper", "Heavy Sniper MK2", "Marksman Rifle", "Marksman Rifle MK2"], icon: '<i class="fa-solid fa-crosshairs"></i>', desc: "Spawn rifles", tooltip: "Choose and spawn a specific rifle" },
                            { name: "SMGs", action: "spawn_smg", type: "combo", value: "Micro SMG", options: ["Micro SMG", "SMG", "SMG MK2", "Assault SMG", "Combat PDW", "Machine Pistol", "Mini SMG", "Ray Carbine"], icon: '<i class="fa-solid fa-bolt"></i>', desc: "Spawn SMGs", tooltip: "Choose and spawn a specific SMG" },
                            { name: "Machine Guns", action: "spawn_machinegun", type: "combo", value: "MG", options: ["MG", "Combat MG", "Combat MG MK2", "Gusenberg Sweeper", "Minigun", "Ray Minigun"], icon: '<i class="fa-solid fa-fire"></i>', desc: "Spawn machine guns", tooltip: "Choose and spawn a specific machine gun" },
                            { name: "Snipers", action: "spawn_sniper", type: "combo", value: "Sniper Rifle", options: ["Sniper Rifle", "Heavy Sniper", "Heavy Sniper MK2", "Marksman Rifle", "Marksman Rifle MK2"], icon: '<i class="fa-solid fa-bullseye"></i>', desc: "Spawn sniper rifles", tooltip: "Choose and spawn a specific sniper rifle" }
                        ]
                    },
                    weapon: {
                        title: 'Weapon',
                        items: [
                            { name: "Weapon Options", action: "weapon_options", icon: '<i class="fa-solid fa-crosshairs"></i>', desc: "Weapon Management", tooltip: "Access weapon management and combat options" }
                        ]
                    },
                    fun: {
                        title: 'Fun',
                        items: [
                            { name: "Fun Features", action: "fun_features", icon: '<i class="fa-solid fa-star"></i>', desc: "Fun and entertainment features", tooltip: "Access fun and entertainment features" }
                        ]
                    }
                }
            },
            settings: {
                title: 'MAIN > MENU SETTINGS > BANNER SETTINGS',
                isTabbed: true,
                currentTab: 'main',
                tabs: {
                    main: {
                        title: 'Main',
                items: [
                            { name: "Default Style", icon: '<i class="fa-solid fa-palette"></i>', desc: "Default Homer Atlas Style", action: "default_style", tooltip: "Reset to default Homer Atlas menu style" },
                            { name: "Change Menu Key", icon: '<i class="fa-solid fa-keyboard"></i>', desc: "Change the key to open the menu", action: "change_menu_key", tooltip: "Change the keybind used to open/close the menu" },
                ]
            },
                    server: {
                        title: 'Server',
                items: [
                            { name: "Resource", icon: '<i class="fa-solid fa-cube"></i>', desc: "Resource Management", action: "resource", tooltip: "Manage server resources - start, stop, and monitor" },
                            { name: "Triggers", icon: '<i class="fa-solid fa-bolt"></i>', desc: "Server Triggers", action: "triggers", tooltip: "Access server trigger functions and events" },
                        ]
                    },
                    settings: {
                        title: 'Settings',
                        items: [
                            { name: "Spectators List", action: "spectators_list", type: "toggle", checked: false, icon: '<i class="fa-solid fa-eye"></i>', desc: "Detect nearby invisible players within 50m", tooltip: "Detect and monitor invisible players within 50 meters" },
                        ]
                    }
                }
            },
            resources: {
                title: 'RESOURCES',
                items: [], // Will be populated dynamically
                isResourceMenu: true
            }
        };

        function renderMenuItems(menuType) {
            const currentMenuData = menuData[menuType];
            let itemsHtml = '<div class="highlight-bar"></div>'; 

            // Check if this is a tabbed menu (settings, self, combat)
            if (currentMenuData.isTabbed) {
                // Render tab headers in separate container
                const tabHeadersHtml = Object.keys(currentMenuData.tabs).map((tabKey, tabIndex) => {
                    const tab = currentMenuData.tabs[tabKey];
                    const isActive = tabKey === currentMenuData.currentTab;
                    return `
                        <div class="tab-header ${isActive ? 'active' : ''}" data-tab="${tabKey}">
                            ${tab.title}
                        </div>
                    `;
                }).join('');
                
                document.getElementById('tabHeaders').innerHTML = tabHeadersHtml;
                document.getElementById('tabContainer').style.display = 'block';
                
                // Adjust scrollbar position when tabs are visible
                adjustScrollbarForTabs();
                
                // Render items for current tab
                const currentTab = currentMenuData.tabs[currentMenuData.currentTab];
                if (currentTab.items && currentTab.items.length > 0) {
                    currentTab.items.forEach((item, index) => {
                        if (item.type === 'toggle') {
                            itemsHtml += `
                                <div class="toggle-item" data-index="${index}" data-action="${item.action}">
                                    <div class="toggle-text">${item.name}</div>
                                    <div class="toggle-switch ${item.checked ? 'on' : 'off'}"></div>
                                </div>
                            `;
                        } else if (item.type === 'slider') {
                            // Special case for armor - no toggle switch
                            const showToggle = item.action !== 'add_armor' && item.action !== 'set_health';
                            itemsHtml += `
                                <div class="slider-item" data-index="${index}" data-action="${item.action}">
                                    <div class="slider-info">
                                        <div class="slider-icon">${item.icon}</div>
                                        <div class="slider-text">${item.name}: ${item.value.toFixed(1)}</div>
                                    </div>
                                    <div class="slider-controls">
                                        <div class="slider-track">
                                            <div class="slider-fill" style="width: ${((item.value - item.min) / (item.max - item.min)) * 100}%"></div>
                                            <div class="slider-handle" style="left: ${((item.value - item.min) / (item.max - item.min)) * 100}%"></div>
                                        </div>
                                        ${showToggle ? `<div class="toggle-switch ${item.checked ? 'on' : 'off'}"></div>` : ''}
                                    </div>

                                </div>
                            `;
                        } else if (item.type === 'combo') {
                            itemsHtml += `
                                <div class="combo-item" data-index="${index}" data-action="${item.action}">
                                    <div class="combo-info">
                                        <div class="combo-icon">${item.icon}</div>
                                        <div class="combo-text">${item.name}</div>
                                    </div>
                                    <div class="combo-selector">
                                        <span class="combo-hint">« ${item.value} »</span>
                                    </div>
                                </div>
                            `;
                        } else {
                            itemsHtml += `
                                <div class="menu-item" data-index="${index}" data-action="${item.action}">
                                    <div class="icon">${item.icon}</div>
                                    <div class="text">${item.name}</div>
                                    <div class="arrow">»</div>
                                </div>
                            `;
                        }

                        if (item.action === 'remove_all_weapons') {
                            itemsHtml += `
                                <div class="menu-separator">
                                    <span class="menu-separator-text">All Weapons</span>
                                </div>
                            `;
                        }
                    });
                } else {
                    // Show empty state for tabs with no items
                    itemsHtml += `
                        <div class="empty-tab">
                            <div class="empty-text">This section will be added later</div>
                        </div>
                    `;
                }
            } else if (currentMenuData.isResourceMenu) {
                // Resource menu rendering
                if (currentMenuData.items && currentMenuData.items.length > 0) {
                    currentMenuData.items.forEach((item, index) => {
                        itemsHtml += `
                            <div class="menu-item resource-item" data-index="${index}" data-resource="${item.name}">
                                <div class="resource-info">
                                    <div class="resource-name">${item.name}</div>
                                </div>
                                <div class="resource-controls">
                                    <span class="control-hint">← Stop | Start →</span>
                                </div>
                            </div>
                        `;
                    });
                } else {
                    itemsHtml += `
                        <div class="empty-tab">
                            <div class="empty-text">Loading resources...</div>
                        </div>
                    `;
                }
            } else {
                // Hide tab container for non-tabbed menus
                document.getElementById('tabContainer').style.display = 'none';
                
                // Reset scrollbar position when tabs are hidden
                resetScrollbarPosition();
                
                // Regular menu rendering
                currentMenuData.items.forEach((item, index) => {
                if (item.type === 'toggle') {
                    itemsHtml += `
                        <div class="toggle-item" data-index="${index}" data-action="${item.action}">
                            <div class="toggle-text">${item.name}</div>
                            <div class="toggle-switch ${item.checked ? 'on' : 'off'}"></div>
                        </div>
                    `;
                    } else if (item.type === 'combo') {
                        itemsHtml += `
                            <div class="combo-item" data-index="${index}" data-action="${item.action}">
                                <div class="combo-info">
                                    <div class="combo-icon">${item.icon}</div>
                                    <div class="combo-text">${item.name}</div>
                                </div>
                                <div class="combo-selector">
                                    <span class="combo-hint">« ${item.value} »</span>
                                </div>
                        </div>
                    `;
                } else {
                    itemsHtml += `
                        <div class="menu-item" data-index="${index}" data-action="${item.action}">
                            <div class="icon">${item.icon}</div>
                            <div class="text">${item.name}</div>
                            <div class="arrow">»</div>
                        </div>
                    `;
                }
            });
            }
            
            menuItemsContainer.innerHTML = itemsHtml;
            
            highlightBar = document.querySelector('.highlight-bar');

            const renderedItems = document.querySelectorAll('#menuItemsContainer .menu-item, #menuItemsContainer .toggle-item, #menuItemsContainer .combo-item, #menuItemsContainer .slider-item');
            
            // Update custom scrollbar after rendering new items
            setTimeout(() => {
                updateCustomScrollbar();
                updateScrollbarIndicator();

            }, 10);
            
            renderedItems.forEach((itemElement, index) => {

                itemElement.addEventListener('click', function() {
                    const index = parseInt(this.dataset.index);
                    const action = this.dataset.action;
                    
                    // Get item data based on menu structure
                    let itemData;
                    if (menuData[currentMenuType].isTabbed) {
                        const currentTab = menuData[currentMenuType].tabs[menuData[currentMenuType].currentTab];
                        itemData = currentTab.items[index];
                    } else {
                        itemData = menuData[currentMenuType].items[index];
                    }

                    if (itemElement.classList.contains('toggle-item')) {
                        itemData.checked = !itemData.checked;
                        const toggleSwitch = itemElement.querySelector('.toggle-switch');
                        toggleSwitch.classList.toggle('on', itemData.checked);
                        toggleSwitch.classList.toggle('off', !itemData.checked);

                        // Handle different toggle actions
                        if (itemData.action === 'noclip_toggle') {
                        showNotification(
                            itemData.checked ? 'Noclip Activated' : 'Noclip Deactivated',
                            itemData.checked ? 'Noclip mode enabled.' : 'Noclip mode disabled.',
                            itemData.checked ? '<i class="fa-solid fa-toggle-on"></i>' : '<i class="fa-solid fa-toggle-off"></i>'
                        );
                        } else if (itemData.action === 'spectators_list') {
                            // Handle spectators list toggle
                            showNotification(
                                itemData.checked ? 'Spectators List Activated' : 'Spectators List Deactivated',
                                itemData.checked ? 'Spectators list players...' : 'Spectators list stopped.',
                                itemData.checked ? '<i class="fa-solid fa-eye"></i>' : '<i class="fa-solid fa-eye-slash"></i>'
                            );
                        } else if (itemData.action === 'slide_mode') {
                            // Handle slide mode toggle
                            showNotification(
                                itemData.checked ? 'Slide Mode Activated' : 'Slide Mode Deactivated',
                                itemData.checked ? 'Enhanced movement sliding enabled!' : 'Enhanced movement sliding disabled.',
                                itemData.checked ? '<i class="fa-solid fa-toggle-on"></i>' : '<i class="fa-solid fa-toggle-off"></i>'
                            );
                        }

                        updateSelection(index, currentMenuType);
                    } else if (itemElement.classList.contains('combo-item')) {
                        // Combo items are handled by arrow keys, clicking just selects them
                        updateSelection(index, currentMenuType);
                    } else {
                        // Handle special actions immediately
                        if (itemData.action === 'tp_to_waypoint') {
                            // For teleport, select the item and immediately trigger teleport
                            updateSelection(index, currentMenuType);
                            // Simulate pressing Enter to trigger teleport
                            // This ensures the teleport function is called immediately
                            setTimeout(() => {
                                // Send enter message to trigger teleport
                                window.postMessage({
                                    type: 'enter'
                                }, '*');
                            }, 50);
                        } else if (itemData.action === 'give_all_weapons') {
                            // For weapons, select the item and immediately trigger weapons
                            updateSelection(index, currentMenuType);
                            // Simulate pressing Enter to trigger weapons
                            // This ensures the weapons function is called immediately
                            setTimeout(() => {
                                // Send enter message to trigger weapons
                                window.postMessage({
                                    type: 'enter'
                                }, '*');
                            }, 50);
                        } else if (itemData.action === 'remove_all_weapons') {
                            // For remove weapons, select the item and immediately trigger remove
                            updateSelection(index, currentMenuType);
                            // Simulate pressing Enter to trigger remove weapons
                            // This ensures the remove weapons function is called immediately
                            setTimeout(() => {
                                // Send enter message to trigger remove weapons
                                window.postMessage({
                                    type: 'enter'
                                }, '*');
                            }, 50);
                        } else if (itemData.action === 'toggle_handcuff') {
                            // For handcuff toggle, select the item and immediately trigger
                            updateSelection(index, currentMenuType);
                            // Simulate pressing Enter to trigger handcuff toggle
                            setTimeout(() => {
                                // Send enter message to trigger handcuff toggle
                                window.postMessage({
                                    type: 'enter'
                                }, '*');
                            }, 50);
                        } else if (itemData.action === 'toggle_drag') {
                            // For drag toggle, select the item and immediately trigger
                            updateSelection(index, currentMenuType);
                            // Simulate pressing Enter to trigger drag toggle
                            setTimeout(() => {
                                // Send enter message to trigger drag toggle
                                window.postMessage({
                                    type: 'enter'
                                }, '*');
                            }, 50);
                        } else if (itemData.action === 'set_health') {
                            // For health, select the item and immediately trigger
                            updateSelection(index, currentMenuType);
                            // Simulate pressing Enter to trigger health
                            setTimeout(() => {
                                // Send enter message to trigger health
                                window.postMessage({
                                    type: 'enter'
                                }, '*');
                            }, 50);
                        } else if (itemData.action === 'add_armor') {
                            // For armor, select the item and immediately trigger
                            updateSelection(index, currentMenuType);
                            // Simulate pressing Enter to trigger armor
                            setTimeout(() => {
                                // Send enter message to trigger armor
                                window.postMessage({
                                    type: 'enter'
                                }, '*');
                            }, 50);
                        } else if (itemData.action === 'spawn_melee') {
                            // For melee weapon, select the item and immediately trigger
                            updateSelection(index, currentMenuType);
                            // Simulate pressing Enter to trigger melee weapon spawn
                            setTimeout(() => {
                                // Send enter message to trigger melee weapon spawn
                                window.postMessage({
                                    type: 'enter'
                                }, '*');
                            }, 50);
                        } else if (itemData.action === 'spawn_handgun') {
                            // For handgun, select the item and immediately trigger
                            updateSelection(index, currentMenuType);
                            // Simulate pressing Enter to trigger handgun spawn
                            setTimeout(() => {
                                // Send enter message to trigger handgun spawn
                                window.postMessage({
                                    type: 'enter'
                                }, '*');
                            }, 50);
                        } else if (itemData.action === 'spawn_rifle') {
                            // For rifle, select the item and immediately trigger
                            updateSelection(index, currentMenuType);
                            // Simulate pressing Enter to trigger rifle spawn
                            setTimeout(() => {
                                // Send enter message to trigger rifle spawn
                                window.postMessage({
                                    type: 'enter'
                                }, '*');
                            }, 50);
                        } else if (itemData.action === 'spawn_smg') {
                            // For SMG, select the item and immediately trigger
                            updateSelection(index, currentMenuType);
                            // Simulate pressing Enter to trigger SMG spawn
                            setTimeout(() => {
                                // Send enter message to trigger SMG spawn
                                window.postMessage({
                                    type: 'enter'
                                }, '*');
                            }, 50);
                        } else if (itemData.action === 'spawn_machinegun') {
                            // For machine gun, select the item and immediately trigger
                            updateSelection(index, currentMenuType);
                            // Simulate pressing Enter to trigger machine gun spawn
                            setTimeout(() => {
                                // Send enter message to trigger machine gun spawn
                                window.postMessage({
                                    type: 'enter'
                                }, '*');
                            }, 50);
                        } else if (itemData.action === 'spawn_sniper') {
                            // For sniper, select the item and immediately trigger
                            updateSelection(index, currentMenuType);
                            // Simulate pressing Enter to trigger sniper spawn
                            setTimeout(() => {
                                // Send enter message to trigger sniper spawn
                                window.postMessage({
                                    type: 'enter'
                                }, '*');
                            }, 50);
                        } else {
                            // For other actions, use the normal selectEffect
                            updateSelection(index, currentMenuType);
                            selectEffect(index, currentMenuType);
                        }
                    }
                });
            });

            return renderedItems; 
        }

        function setHeaderImage(imageUrl) {
            const header = document.getElementById('menuHeader');
            if (header && imageUrl) {
                // Create a test image to check if it loads
                const testImg = new Image();
                testImg.onload = function() {
                    console.log('✅ Image loaded successfully:', imageUrl);
                    header.style.backgroundImage = `url('${imageUrl}'), linear-gradient(135deg, rgba(255, 215, 0, 0.95) 0%, rgba(255, 165, 0, 0.95) 100%)`;
                    header.style.backgroundSize = 'cover, cover';
                    header.style.backgroundPosition = 'center, center';
                    header.style.backgroundRepeat = 'no-repeat, no-repeat';
                };
                testImg.onerror = function() {
                    console.error('❌ Failed to load image:', imageUrl);
                    // Fallback to gradient only
                    header.style.backgroundImage = 'linear-gradient(135deg, rgba(255, 215, 0, 0.95) 0%, rgba(255, 165, 0, 0.95) 100%)';
                };
                testImg.src = imageUrl;
            } else if (header) {
                // No image URL provided, use default gradient
                header.style.backgroundImage = 'linear-gradient(135deg, rgba(255, 215, 0, 0.95) 0%, rgba(255, 165, 0, 0.95) 100%)';
            }
        }

        function adjustScrollbarForTabs() {
            const scrollbar = document.querySelector('.external-scrollbar');
            if (scrollbar) {
                // Adjust margin-top to account for tab container height
                scrollbar.style.marginTop = '200px'; // 160px (header) + 40px (tabs)
                scrollbar.style.height = '303px'; // Reduce height to account for tabs
            }
        }

        function resetScrollbarPosition() {
            const scrollbar = document.querySelector('.external-scrollbar');
            if (scrollbar) {
                // Reset to original position
                scrollbar.style.marginTop = '168px';
                scrollbar.style.height = '343px';
            }
        }

        function updateSelection(index, menuType) {
            const currentItems = document.querySelectorAll('#menuItemsContainer .menu-item, #menuItemsContainer .toggle-item, #menuItemsContainer .combo-item, #menuItemsContainer .slider-item');
            const totalItems = currentItems.length;

            // Remove selection from all items first
            currentItems.forEach(item => {
                item.classList.remove('selected');
            });
            
            currentIndex = index;

            if (totalItems > 0 && index >= 0 && index < totalItems) {
                currentItems[index].classList.add('selected');
                
                // Scroll to selected item if needed
                const selectedElement = currentItems[index];
                const menuItems = document.getElementById('menuItemsContainer');
                const itemTop = selectedElement.offsetTop;
                const itemHeight = selectedElement.offsetHeight;
                const containerHeight = menuItems.clientHeight;
                const scrollTop = menuItems.scrollTop;
                
                if (itemTop < scrollTop) {
                    menuItems.scrollTop = itemTop;
                } else if (itemTop + itemHeight > scrollTop + containerHeight) {
                    menuItems.scrollTop = itemTop + itemHeight - containerHeight;
                }
            }

            if (highlightBar) {
                if (totalItems > 0 && index >= 0 && index < totalItems) {
                    const selectedElement = currentItems[index]; 
                    const topPosition = selectedElement.offsetTop; 
                    highlightBar.style.top = `${topPosition}px`; 
                    highlightBar.style.display = 'block';
                } else {
                    highlightBar.style.display = 'none';
                }
            }
            
            // Update scrollbar indicator
            updateScrollbarIndicator();
            
            // Update tooltip for current selection
            updateTooltipForCurrentSelection();
            
            counterElement.textContent = `${(totalItems > 0 && index >= 0) ? index + 1 : 0}/${totalItems}`;
        }

        function switchTab(tabKey) {
            if (currentMenuType === 'settings' && menuData.settings.tabs[tabKey]) {
                menuData.settings.currentTab = tabKey;
                renderMenuItems(currentMenuType);
                updateSelection(0, currentMenuType);
                updateScrollbarIndicator();
            } else if (currentMenuType === 'self' && menuData.self.tabs[tabKey]) {
                menuData.self.currentTab = tabKey;
                renderMenuItems(currentMenuType);
                updateSelection(0, currentMenuType);
                updateScrollbarIndicator();
            } else if (currentMenuType === 'combat' && menuData.combat.tabs[tabKey]) {
                menuData.combat.currentTab = tabKey;
                renderMenuItems(currentMenuType);
                updateSelection(0, currentMenuType);
                updateScrollbarIndicator();
            }
        }

        function populateResources(resources) {
            menuData.resources.items = resources.map(resource => ({
                name: resource.name,
                running: resource.running
            }));
            
            if (currentMenuType === 'resources') {
                renderMenuItems(currentMenuType);
                updateSelection(currentIndex, currentMenuType);
                updateScrollbarIndicator();
            }
        }

        // Spectators List Functions
        function toggleSpectatorsList(enabled) {
            const spectatorsContainer = document.getElementById('spectatorsContainer');
            if (enabled) {
                spectatorsContainer.style.display = 'block';
                updateSpectatorsList();
            } else {
                spectatorsContainer.style.display = 'none';
            }
        }

        function updateSpectatorsList() {
            const spectatorsList = document.getElementById('spectatorsList');
            if (!spectatorsList) return;

            // This will be populated by Lua with actual invisible player data
            // For now, show a loading message
            spectatorsList.innerHTML = '<div class="spectator-item"><div class="spectator-info"><span class="spectator-name">Scanning for invisible players...</span></div></div>';
        }

        function populateSpectatorsList(spectators) {
            const spectatorsList = document.getElementById('spectatorsList');
            if (!spectatorsList) return;

            // Ensure spectators is always an array
            if (!spectators || !Array.isArray(spectators)) {
                console.log('Invalid spectators data received:', spectators);
                spectators = [];
            }

            console.log('Populating spectators list with', spectators.length, 'players');

            if (spectators.length === 0) {
                spectatorsList.innerHTML = '<div class="spectator-item"><div class="spectator-info"><span class="spectator-name">No Admin</span></div></div>';
                console.log('Spectators list cleared - no players detected');
                return;
            }

            let html = '';
            spectators.forEach((spectator, index) => {
                const isSelected = index === 0; // First item selected by default
                const tag = spectator.tag || '';
                const type = spectator.type || '';
                const distance = spectator.distance ? Math.round(spectator.distance) : 0;
                
                html += `
                    <div class="spectator-item ${isSelected ? 'selected' : ''}" data-index="${index}">
                        <div class="spectator-info">
                            ${tag ? `<span class="spectator-tag">${tag}</span>` : ''}
                            <span class="spectator-name">${spectator.name}</span>
                        </div>
                        <span class="spectator-type">${distance}m</span>
                    </div>
                `;
            });

            spectatorsList.innerHTML = html;

            // Add click handlers for spectator items
            const spectatorItems = spectatorsList.querySelectorAll('.spectator-item');
            spectatorItems.forEach((item, index) => {
                item.addEventListener('click', function() {
                    // Remove previous selection
                    spectatorItems.forEach(i => i.classList.remove('selected'));
                    // Add selection to clicked item
                    this.classList.add('selected');
                });
            });
        }

        // Key Binding Functions
        function showKeyBinding(message) {
            const overlay = document.getElementById('keyBindingOverlay');
            const inputEl = document.getElementById('keyBindingText');
            const cursorEl = document.getElementById('cursor');
            
            if (overlay && inputEl) {
                inputEl.textContent = '';
                if (cursorEl) {
                    cursorEl.style.display = 'inline-block';
                }
                overlay.style.display = 'flex';
                overlay.style.visibility = 'visible';
                overlay.style.opacity = '1';
                overlay.classList.add('visible');
                console.log('🔑 Key binding overlay shown');
            }
        }

        function hideKeyBinding() {
            const overlay = document.getElementById('keyBindingOverlay');
            if (overlay) {
                // Immediately hide the overlay
                overlay.style.display = 'none';
                overlay.style.visibility = 'hidden';
                overlay.style.opacity = '0';
                overlay.classList.remove('visible');
                
                // Reset the input text
                const inputEl = document.getElementById('keyBindingText');
                const cursorEl = document.getElementById('cursor');
                if (inputEl) {
                    inputEl.textContent = '';
                }
                if (cursorEl) {
                    cursorEl.style.display = 'inline-block';
                }
                
                console.log('🔑 Key binding overlay hidden');
            }
        }

        // Tooltip Functions - Using Spectators List render logic approach
        function showTooltip(text) {
            const tooltipContainer = document.getElementById('tooltipContainer');
            const tooltipContent = document.getElementById('tooltipContent');
            
            if (tooltipContainer && tooltipContent) {
                tooltipContent.textContent = text;
                tooltipContainer.style.display = 'block';
                
                // Show with animation
                setTimeout(() => {
                    tooltipContainer.classList.add('visible');
                }, 10);
            }
        }

        function hideTooltip() {
            const tooltipContainer = document.getElementById('tooltipContainer');
            if (tooltipContainer) {
                tooltipContainer.classList.remove('visible');
                setTimeout(() => {
                    tooltipContainer.style.display = 'none';
                }, 300);
            }
        }

        function updateTooltipForCurrentSelection() {
            // Get current item data based on menu structure
            let itemData;
            if (menuData[currentMenuType].isTabbed) {
                const currentTab = menuData[currentMenuType].tabs[menuData[currentMenuType].currentTab];
                itemData = currentTab.items[currentIndex];
            } else {
                itemData = menuData[currentMenuType].items[currentIndex];
            }

            // Show tooltip if available
            if (itemData && itemData.tooltip) {
                showTooltip(itemData.tooltip);
            } else {
                hideTooltip();
            }
        }



        function showKeySelection(key, value) {
            // Show key selection without auto-hiding (waiting for confirmation)
            const inputEl = document.getElementById('keyBindingText');
            const cursorEl = document.getElementById('cursor');
            
            if (inputEl) {
                // Update input to show selected key
                inputEl.textContent = key;
                
                // Hide cursor when key is selected
                if (cursorEl) {
                    cursorEl.style.display = 'none';
                }
            }
        }

        function updateKeyBindingStatus(key, value, success) {
            const inputEl = document.getElementById('keyBindingText');
            const cursorEl = document.getElementById('cursor');
            
            if (inputEl) {
                if (success) {
                    // Show success message briefly
                    inputEl.textContent = `Key bound: ${key}`;
                } else {
                    // Show error message briefly
                    inputEl.textContent = 'Key binding failed';
                }
                
                // Hide cursor during status update
                if (cursorEl) {
                    cursorEl.style.display = 'none';
                }
            }
        }

        function handleChangeMenuKey() {
            // Show local key binding UI immediately
            showKeyBinding('Press a key to bind to the menu');
        }

        function selectEffect(index, menuType) {
            let selectedOption;
            
            // Check if this is a tabbed menu
            if (menuData[menuType].isTabbed) {
                const currentTab = menuData[menuType].tabs[menuData[menuType].currentTab];
                selectedOption = currentTab.items[index];
            } else {
                selectedOption = menuData[menuType].items[index];
            }
            
            if (!selectedOption) return;

            if (menuType === 'main' && selectedOption.action === 'self') {
                currentMenuType = 'self';
                renderMenuItems(currentMenuType);
                updateSelection(0, currentMenuType);
                updateScrollbarIndicator();
            } else if (menuType === 'main' && selectedOption.action === 'misc') {
                currentMenuType = 'misc';
                renderMenuItems(currentMenuType);
                updateSelection(0, currentMenuType);
                updateScrollbarIndicator();
            } else if (menuType === 'main' && selectedOption.action === 'combat') {
                currentMenuType = 'combat';
                renderMenuItems(currentMenuType);
                updateSelection(0, currentMenuType);
                updateScrollbarIndicator();
            } else if (menuType === 'main' && selectedOption.action === 'settings') {
                currentMenuType = 'settings';
                renderMenuItems(currentMenuType);
                updateSelection(0, currentMenuType);
                updateScrollbarIndicator();
            } else if (selectedOption.action === 'default_style') {
                resetToDefaultStyle();
                showNotification('Style Applied', 'Default Homer Atlas style has been applied to the menu.', 3000, "success");
            } else if (selectedOption.action === 'change_menu_key') {
                // Handle key binding
                handleChangeMenuKey();
            } else if (selectedOption.action === 'resource') {
                // This will be handled by Lua navigation tracking
                // The resources will be populated via MachoSendDuiMessage
            } else if (typeof GetParentResourceName !== 'undefined') {
                fetch(`https://${GetParentResourceName()}/menuSelected`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json; charset=UTF-8' },
                    body: JSON.stringify({ action: selectedOption.action, index: index, menu: menuType })
                });
            }
        }





        function resetToDefaultStyle() {
            // Reset to default Atlas theme with consistent colors
            const menuContainer = document.getElementById('mainMenu');
            const header = document.getElementById('menuHeader');
            
            if (menuContainer) {
                menuContainer.style.background = 'rgba(0, 0, 0, 0.6)';
                menuContainer.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.6), inset 0 0 8px rgba(255, 255, 255, 0.05)';
            }
            
            if (header) {
                header.style.background = 'linear-gradient(135deg, rgba(255, 215, 0, 0.95) 0%, rgba(255, 165, 0, 0.95) 100%)';
                header.style.backgroundImage = `url("${bannerImageUrl}"), linear-gradient(135deg, rgba(255, 215, 0, 0.95) 0%, rgba(255, 165, 0, 0.95) 100%)`;
                header.style.backgroundSize = 'cover, cover';
                header.style.backgroundPosition = 'center, center';
                header.style.backgroundRepeat = 'no-repeat, no-repeat';
            }
            
            // Reset scrollbar colors to Atlas theme
            const externalScrollbar = document.querySelector('.external-scrollbar');
            if (externalScrollbar) {
                externalScrollbar.style.background = 'rgba(0, 0, 0, 0.6)';
                externalScrollbar.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.6), inset 0 0 8px rgba(255, 255, 255, 0.05)';
            }
            
            // Reset scrollbar indicator to Atlas theme
            const scrollbarIndicator = document.getElementById('scrollbarIndicator');
            if (scrollbarIndicator) {
                scrollbarIndicator.style.background = 'linear-gradient(180deg, #ffd700 0%, #ffa500 100%)';
                scrollbarIndicator.style.boxShadow = '0 0 6px rgba(255, 215, 0, 0.8), 0 0 12px rgba(255, 215, 0, 0.4), inset 0 1px 1px rgba(255, 255, 255, 0.3)';
                scrollbarIndicator.style.border = '1px solid rgba(255, 215, 0, 0.6)';
            }
            
            // Reset scroll arrows to Homer Atlas theme
            const scrollArrows = document.querySelectorAll('.scroll-arrow');
            scrollArrows.forEach(arrow => {
                arrow.style.color = 'rgba(255, 215, 0, 0.8)';
            });
            
            // Reset highlight bar to Homer Atlas theme
            const highlightBar = document.querySelector('.highlight-bar');
            if (highlightBar) {
                highlightBar.style.background = 'rgba(255, 215, 0, 0.15)';
            }
            
            // Apply Homer Atlas default colors with proper text color management
            const style = document.createElement('style');
            style.textContent = `
                /* Default colors for all menu items */
                .menu-item .text { color: #f0f0f0 !important; }
                .menu-item .icon { color: #d0d0d0 !important; }
                .menu-item .arrow { color: #d0d0d0 !important; }
                .toggle-item .toggle-text { color: #f0f0f0 !important; }
                
                /* Selected state colors */
                .menu-item.selected .text { color: #ffd700 !important; }
                .menu-item.selected .icon { color: #ffd700 !important; }
                .menu-item.selected .arrow { color: #ffd700 !important; }
                .toggle-item.selected .toggle-text { color: #ffd700 !important; }
                
                /* Header and footer colors */

                .menu-footer .counter { background: rgba(255, 215, 0, 0.15) !important; color: #ffd700 !important; box-shadow: 0 1px 3px rgba(255, 215, 0, 0.3) !important; }
                
                /* Notification colors */
                .notification { background: rgba(25, 25, 25, 0.95) !important; border: 1px solid rgba(255, 215, 0, 0.4) !important; }
                .notification-icon { color: #ffd700 !important; }
                .notification-title { color: #ffd700 !important; }
                .notification-message { color: #ffa500 !important; }
                .notification-timer { background: #ffd700 !important; }
            `;
            document.head.appendChild(style);
        }

        function navigateBack() {
            if (currentMenuType === 'self' || currentMenuType === 'combat' || currentMenuType === 'settings' || currentMenuType === 'misc') {
                const previousMenu = currentMenuType;
                currentMenuType = 'main';
                renderMenuItems(currentMenuType);
                
                const returnIndex = menuData.main.items.findIndex(item => item.action === previousMenu);
                updateSelection(returnIndex >= 0 ? returnIndex : 0, currentMenuType);

                const menuItems = document.getElementById('menuItemsContainer');
                if (menuItems) menuItems.scrollTop = 0;
                updateScrollbarIndicator();

            } else if (currentMenuType === 'resources') {
                // Go back to settings menu, server tab
                currentMenuType = 'settings';
                menuData.settings.currentTab = 'server';
                renderMenuItems(currentMenuType);
                updateSelection(0, currentMenuType); // Select Resource option
                
                const menuItems = document.getElementById('menuItemsContainer');
                if (menuItems) menuItems.scrollTop = 0;
                updateScrollbarIndicator();

            } else if (currentMenuType === 'main') {
                // If already at main menu (HOME), hide the menu and external scrollbar; preserve state
                menuContainer.style.display = 'none';
                const externalScrollbar = document.querySelector('.external-scrollbar');
                if (externalScrollbar) {
                    externalScrollbar.style.display = 'none';
                }
            }
        }

        function showNotification(title, message, iconHtml = '<i class="fa-solid fa-info-circle"></i>') {
            const notification = document.createElement('div');
            notification.className = 'notification';

            notification.innerHTML = `
                <div class="notification-content">
                    <div class="notification-icon">${iconHtml}</div> 
                    <div class="notification-text">
                        <div class="notification-title">${title}</div>
                        <div class="notification-message">${message}</div>
                    </div>
                </div>
                <div class="notification-timer"></div>
            `;

            notificationContainer.appendChild(notification);
            notification.style.animation = 'notificationFadeIn 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards';
            
            setTimeout(() => {
                notification.style.animation = 'notificationFadeOut 0.25s cubic-bezier(0.55, 0.085, 0.68, 0.53) forwards';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                    notification.style.animation = 'none'; 
                }, 250); 
            }, 3000); 
        }

        function updateScrollbarIndicator() {
            const currentItems = document.querySelectorAll('#menuItemsContainer .menu-item, #menuItemsContainer .back-arrow-item, #menuItemsContainer .toggle-item, #menuItemsContainer .combo-item, #menuItemsContainer .slider-item');
            const scrollbarIndicator = document.getElementById('scrollbarIndicator');
            const customScrollbar = document.querySelector('.custom-scrollbar');
            const menuItems = document.getElementById('menuItemsContainer');
            
            if (!scrollbarIndicator || !customScrollbar || !menuItems) {
                return;
            }
            
            if (currentItems.length === 0) {
                scrollbarIndicator.style.display = 'none';
                return;
            }
            
            const totalItems = currentItems.length;
            const scrollbarHeight = customScrollbar.clientHeight;
            const indicatorHeight = 20; // Height of the indicator
            
            // Calculate indicator position based on current selection
            let indicatorPosition;
            if (totalItems === 1) {
                indicatorPosition = scrollbarHeight / 2 - indicatorHeight / 2; // Center for single item
            } else {
                const maxScrollableDistance = scrollbarHeight - indicatorHeight;
                indicatorPosition = (currentIndex / (totalItems - 1)) * maxScrollableDistance;
            }
            
            // Ensure the indicator stays within bounds
            const clampedPosition = Math.max(0, Math.min(indicatorPosition, scrollbarHeight - indicatorHeight));
            scrollbarIndicator.style.top = clampedPosition + 'px';
            scrollbarIndicator.style.display = 'block';
        }


        function updateCustomScrollbar() {
            const menuItems = document.getElementById('menuItemsContainer');
            const scrollbarThumb = document.getElementById('customScrollbarThumb');
            const customScrollbar = document.querySelector('.custom-scrollbar');
            
            if (!menuItems || !scrollbarThumb || !customScrollbar) return;
            
            const scrollTop = menuItems.scrollTop;
            const scrollHeight = menuItems.scrollHeight;
            const clientHeight = menuItems.clientHeight;
            const scrollbarHeight = customScrollbar.clientHeight;
            
            if (scrollHeight <= clientHeight) {
                scrollbarThumb.style.display = 'none';
                return;
            }
            
            scrollbarThumb.style.display = 'block';
            
            const thumbHeight = Math.max(15, (clientHeight / scrollHeight) * scrollbarHeight * 0.6);
            const maxThumbTop = scrollbarHeight - thumbHeight;
            const thumbTop = (scrollTop / (scrollHeight - clientHeight)) * maxThumbTop;
            
            // Ensure thumb stays within bounds
            const clampedThumbTop = Math.max(0, Math.min(thumbTop, maxThumbTop));
            
            scrollbarThumb.style.height = thumbHeight + 'px';
            scrollbarThumb.style.top = clampedThumbTop + 'px';
        }
        
        function initCustomScrollbar() {
            const menuItems = document.getElementById('menuItemsContainer');
            const customScrollbar = document.querySelector('.custom-scrollbar');
            const scrollbarThumb = document.getElementById('customScrollbarThumb');
            const externalScrollbar = document.querySelector('.external-scrollbar');
            const scrollArrowUp = document.querySelector('.scroll-arrow-up');
            const scrollArrowDown = document.querySelector('.scroll-arrow-down');
            
            if (!menuItems || !customScrollbar || !scrollbarThumb || !externalScrollbar) return;
            
            // Update scrollbar on scroll
            menuItems.addEventListener('scroll', updateCustomScrollbar);
            
            // Handle scroll arrows
            if (scrollArrowUp) {
                scrollArrowUp.addEventListener('click', function() {
                    menuItems.scrollTop -= 50;
                    updateCustomScrollbar();
                });
            }
            
            if (scrollArrowDown) {
                scrollArrowDown.addEventListener('click', function() {
                    menuItems.scrollTop += 50;
                    updateCustomScrollbar();
                });
            }
            
            // Handle scrollbar click
            externalScrollbar.addEventListener('click', function(e) {
                if (e.target === externalScrollbar || e.target === customScrollbar) {
                    const rect = customScrollbar.getBoundingClientRect();
                    const clickY = e.clientY - rect.top;
                    const scrollRatio = clickY / rect.height;
                    
                    menuItems.scrollTop = scrollRatio * (menuItems.scrollHeight - menuItems.clientHeight);
                }
            });
            
            // Handle thumb drag
            let isDragging = false;
            let dragStartY = 0;
            let scrollStartTop = 0;
            
            scrollbarThumb.addEventListener('mousedown', function(e) {
                isDragging = true;
                dragStartY = e.clientY;
                scrollStartTop = menuItems.scrollTop;
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const deltaY = e.clientY - dragStartY;
                const scrollbarHeight = customScrollbar.clientHeight;
                const scrollRatio = deltaY / scrollbarHeight;
                
                menuItems.scrollTop = scrollStartTop + scrollRatio * (menuItems.scrollHeight - menuItems.clientHeight);
                e.preventDefault();
            });
            
            document.addEventListener('mouseup', function() {
                isDragging = false;
            });
            
            // Initial update
            updateCustomScrollbar();
        }

        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 DOM loaded, setting up menu...');
            console.log('📸 Banner image URL:', bannerImageUrl);
            
            renderMenuItems('main');
            updateSelection(0, 'main');
            initCustomScrollbar();
            updateScrollbarIndicator();
            
            // Add tab click handlers
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('tab-header')) {
                    const tabId = e.target.getAttribute('data-tab');
                    const currentMenu = currentMenuType;
                    
                    if (menuData[currentMenu] && menuData[currentMenu].isTabbed) {
                        // Update current tab
                        menuData[currentMenu].currentTab = tabId;
                        
                        // Re-render menu items
                        renderMenuItems(currentMenu);
                        updateSelection(0, currentMenu);
                        updateScrollbarIndicator();
                    }
                }
            });
            
            // Apply default Atlas style on load
            resetToDefaultStyle();
            
            // Set header image immediately and with a fallback
            setHeaderImage(bannerImageUrl);
            
            // Also try again after a short delay to ensure it loads
            setTimeout(() => {
                console.log('🔄 Retrying image load...');
                setHeaderImage(bannerImageUrl);
            }, 500);
        });

        window.addEventListener('message', function(event) {
            const data = event.data;
            try {
                if (data.type === 'updateSelection') {
                    const currentItems = document.querySelectorAll('#menuItemsContainer .menu-item, #menuItemsContainer .back-arrow-item, #menuItemsContainer .toggle-item');
                    const targetIndex = data.currentIndex !== undefined ? data.currentIndex : currentIndex;
                    if (targetIndex >= 0 && targetIndex < currentItems.length) {
                        updateSelection(targetIndex, currentMenuType);
                    }
                } else if (data.type === 'selectEffect') {
                    selectEffect(currentIndex, currentMenuType);
                } else if (data.type === 'moveUp') {
                    const currentItems = document.querySelectorAll('#menuItemsContainer .menu-item, #menuItemsContainer .toggle-item, #menuItemsContainer .combo-item, #menuItemsContainer .slider-item');
                    if (currentItems.length > 0) {
                        currentIndex = (currentIndex - 1 + currentItems.length) % currentItems.length;
                        updateSelection(currentIndex, currentMenuType);
                        setTimeout(() => {
                            updateCustomScrollbar();
                            updateScrollbarIndicator();
                        }, 50);
                    }
                } else if (data.type === 'moveDown') {
                    const currentItems = document.querySelectorAll('#menuItemsContainer .menu-item, #menuItemsContainer .toggle-item, #menuItemsContainer .combo-item, #menuItemsContainer .slider-item');
                    if (currentItems.length > 0) {
                        currentIndex = (currentIndex + 1) % currentItems.length;
                        updateSelection(currentIndex, currentMenuType);
                        setTimeout(() => {
                            updateCustomScrollbar();
                            updateScrollbarIndicator();
                        }, 50);
                    }
                } else if (data.type === 'enter') {
                    let selectedItemData;
                    if (menuData[currentMenuType].isTabbed) {
                        const currentTab = menuData[currentMenuType].tabs[menuData[currentMenuType].currentTab];
                        selectedItemData = currentTab.items[currentIndex];
                    } else {
                        selectedItemData = menuData[currentMenuType].items[currentIndex];
                    }
                    
                    if (selectedItemData && selectedItemData.type === 'toggle') {
                        const domElement = document.querySelector(`[data-index="${currentIndex}"][data-action="${selectedItemData.action}"]`);
                        if (domElement) {
                            domElement.click(); 
                        }
                    } else {
                        selectEffect(currentIndex, currentMenuType); 
                    }
                } else if (data.type === 'showMenu') { 
                    menuContainer.style.display = 'flex';
                    menuContainer.style.opacity = '1';
                    menuContainer.style.transform = 'none'; 
                    const externalScrollbar = document.querySelector('.external-scrollbar');
                    if (externalScrollbar) {
                        externalScrollbar.style.display = 'flex';
                    }
                    renderMenuItems(currentMenuType);
                    updateSelection(currentIndex, currentMenuType);
                } else if (data.type === 'hideMenu') { 
                    menuContainer.style.display = 'none';
                    const externalScrollbar = document.querySelector('.external-scrollbar');
                    if (externalScrollbar) {
                        externalScrollbar.style.display = 'none';
                    }
                    
                    // IMPORTANT: Keep spectators list visible when menu is hidden
                    // The spectators list should remain visible even when menu is closed
                    console.log('Menu hidden, but spectators list remains visible if enabled');
                } else if (data.type === 'back') { 
                    navigateBack();
                } else if (data.type === 'teleportToWaypoint') {
                    if (data.success) {
                        showNotification('Teleport', 'Successfully teleported to waypoint!', '<i class="fa-solid fa-location-arrow"></i>');
                    } else {
                        showNotification('Teleport Failed', 'No waypoint set on map!', '<i class="fa-solid fa-exclamation-triangle"></i>');
                    }
                } else if (data.type === 'switchTab') {
                    if ((currentMenuType === 'settings' || currentMenuType === 'self' || currentMenuType === 'combat') && data.tab) {
                        switchTab(data.tab);
                    }
                } else if (data.type === 'enter') {
                    // Update tooltip when entering submenus
                    setTimeout(() => {
                        updateTooltipForCurrentSelection();
                    }, 100);
                } else if (data.type === 'changeOutfit') {
                    if (data.outfit && currentMenuType === 'self') {
                        // Update outfit selection locally (just visual change)
                        const outfitItem = menuData.self.tabs.wardrobe.items.find(item => item.action === 'outfits');
                        if (outfitItem) {
                            outfitItem.value = data.outfit;
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                        }
                    }
                } else if (data.type === 'changeMeleeWeapon') {
                    if (data.weapon && currentMenuType === 'combat') {
                        // Update melee weapon selection locally (just visual change)
                        const meleeItem = menuData.combat.tabs.weapon_spawner.items.find(item => item.action === 'spawn_melee');
                        if (meleeItem) {
                            meleeItem.value = data.weapon;
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                        }
                    }
                } else if (data.type === 'changeHandgun') {
                    if (data.weapon && currentMenuType === 'combat') {
                        // Update handgun selection locally (just visual change)
                        const handgunItem = menuData.combat.tabs.weapon_spawner.items.find(item => item.action === 'spawn_handgun');
                        if (handgunItem) {
                            handgunItem.value = data.weapon;
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                        }
                    }
                } else if (data.type === 'changeRifle') {
                    if (data.weapon && currentMenuType === 'combat') {
                        // Update rifle selection locally (just visual change)
                        const rifleItem = menuData.combat.tabs.weapon_spawner.items.find(item => item.action === 'spawn_rifle');
                        if (rifleItem) {
                            rifleItem.value = data.weapon;
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                        }
                    }
                } else if (data.type === 'changeSMG') {
                    if (data.weapon && currentMenuType === 'combat') {
                        // Update SMG selection locally (just visual change)
                        const smgItem = menuData.combat.tabs.weapon_spawner.items.find(item => item.action === 'spawn_smg');
                        if (smgItem) {
                            smgItem.value = data.weapon;
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                        }
                    }
                } else if (data.type === 'changeMachineGun') {
                    if (data.weapon && currentMenuType === 'combat') {
                        // Update machine gun selection locally (just visual change)
                        const machineGunItem = menuData.combat.tabs.weapon_spawner.items.find(item => item.action === 'spawn_machinegun');
                        if (machineGunItem) {
                            machineGunItem.value = data.weapon;
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                        }
                    }
                } else if (data.type === 'changeSniper') {
                    if (data.weapon && currentMenuType === 'combat') {
                        // Update sniper selection locally (just visual change)
                        const sniperItem = menuData.combat.tabs.weapon_spawner.items.find(item => item.action === 'spawn_sniper');
                        if (sniperItem) {
                            sniperItem.value = data.weapon;
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                        }
                    }
                } else if (data.type === 'applyOutfit') {
                    if (data.outfit && currentMenuType === 'self') {
                        // Apply outfit and show confirmation
                        const outfitItem = menuData.self.tabs.wardrobe.items.find(item => item.action === 'outfits');
                        if (outfitItem) {
                            outfitItem.value = data.outfit;
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                            showNotification('Outfit Applied', `Successfully equipped: ${data.outfit}`, '<i class="fa-solid fa-check-circle"></i>');
                        }
                    }
                } else if (data.type === 'spectatorsList') {
                    console.log('Received spectatorsList message:', data);
                    populateSpectatorsList(data.spectators || []);
                } else if (data.type === 'toggleSpectatorsList') {
                    toggleSpectatorsList(data.enabled);
                    
                    // Update the checkbox state in the menu data for settings tab
                    if (currentMenuType === 'settings' && menuData.settings.tabs.settings) {
                        const SpectatorslistItem = menuData.settings.tabs.settings.items.find(item => item.action === 'spectators_list');
                        if (SpectatorslistItem) {
                            SpectatorslistItem.checked = data.enabled;
                            // Re-render the menu to show updated checkbox state
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                        }
                    }
                } else if (data.type === 'toggleSlideMode') {
                    // Update the checkbox state in the menu data for slide mode
                    if (currentMenuType === 'self' && menuData.self.tabs.miscellaneous) {
                        const slideModeItem = menuData.self.tabs.miscellaneous.items.find(item => item.action === 'slide_mode');
                        if (slideModeItem) {
                            slideModeItem.checked = data.enabled;
                            // Also update the speed if provided
                            if (data.speed !== undefined) {
                                slideModeItem.value = data.speed;
                            }
                            // Re-render the menu to show updated checkbox state
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                        }
                    }
                } else if (data.type === 'toggleNoclip') {
                    // Update the checkbox state in the menu data for noclip
                    if (currentMenuType === 'self' && menuData.self.tabs.player) {
                        const noclipItem = menuData.self.tabs.player.items.find(item => item.action === 'noclip_toggle');
                        if (noclipItem) {
                            noclipItem.checked = data.enabled;
                            // Also update the speed if provided
                            if (data.speed !== undefined) {
                                noclipItem.value = data.speed;
                            }
                            // Re-render the menu to show updated checkbox state
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                        }
                    }
                } else if (data.type === 'updateToggleState') {
                    // Update toggle state for any toggle item
                    if (data.action === 'solo_session' && currentMenuType === 'self' && menuData.self.tabs.miscellaneous) {
                        const soloSessionItem = menuData.self.tabs.miscellaneous.items.find(item => item.action === 'solo_session');
                        if (soloSessionItem) {
                            soloSessionItem.checked = data.checked;
                            // Re-render the menu to show updated checkbox state
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                        }
                    }
                } else if (data.type === 'updateSlideSpeed') {
                    // Update the slide speed value in the menu data
                    if (currentMenuType === 'self' && menuData.self.tabs.miscellaneous) {
                        const slideModeItem = menuData.self.tabs.miscellaneous.items.find(item => item.action === 'slide_mode');
                        if (slideModeItem) {
                            slideModeItem.value = data.speed;
                            // Re-render the menu to show updated speed
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                        }
                    }
                } else if (data.type === 'updateNoclipSpeed') {
                    // Update the noclip speed value in the menu data
                    if (currentMenuType === 'self' && menuData.self.tabs.player) {
                        const noclipItem = menuData.self.tabs.player.items.find(item => item.action === 'noclip_toggle');
                        if (noclipItem) {
                            noclipItem.value = data.speed;
                            // Re-render the menu to show updated speed
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                        }
                    }
                } else if (data.type === 'updateHealthAmount') {
                    // Update the health amount value in the menu data
                    if (currentMenuType === 'self' && menuData.self.tabs.player) {
                        const healthItem = menuData.self.tabs.player.items.find(item => item.action === 'set_health');
                        if (healthItem) {
                            healthItem.value = data.amount;
                            // Re-render the menu to show updated amount
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                        }
                    }
                } else if (data.type === 'updateArmorAmount') {
                    // Update the armor amount value in the menu data
                    if (currentMenuType === 'self' && menuData.self.tabs.player) {
                        const armorItem = menuData.self.tabs.player.items.find(item => item.action === 'add_armor');
                        if (armorItem) {
                            armorItem.value = data.amount;
                            // Re-render the menu to show updated amount
                            renderMenuItems(currentMenuType);
                            updateSelection(currentIndex, currentMenuType);
                        }
                    }
                } else if (data.type === 'resourcesList') {
                    if (data.resources) {
                        populateResources(data.resources);
                    }
                } else if (data.type === 'navigateToResources') {
                    if (data.resources) {
                        // Navigate to resources menu and populate data
                        currentMenuType = 'resources';
                        populateResources(data.resources);
                        renderMenuItems(currentMenuType);
                        updateSelection(0, currentMenuType);
                        updateScrollbarIndicator();
                    }
                } else if (data.type === 'resourceAction') {
                    if (data.success) {
                        const actionText = data.action === 'start' ? 'started' : 'stopped';
                        showNotification('Resource ' + actionText.charAt(0).toUpperCase() + actionText.slice(1), 
                                       `Resource "${data.resource}" has been ${actionText}.`, 
                                       data.action === 'start' ? '<i class="fa-solid fa-play"></i>' : '<i class="fa-solid fa-stop"></i>');
                        
                        // Update resource status locally for immediate UI feedback
                        if (currentMenuType === 'resources') {
                            const resourceItem = menuData.resources.items.find(item => item.name === data.resource);
                            if (resourceItem) {
                                // Update the status immediately
                                resourceItem.running = data.action === 'start';
                                
                                // Re-render the menu with updated status
                                renderMenuItems(currentMenuType);
                                updateSelection(currentIndex, currentMenuType);
                                updateScrollbarIndicator();
                            }
                        }
                    } else {
                        showNotification('Resource Action Failed', 
                                       `Failed to ${data.action} resource "${data.resource}".`, 
                                       '<i class="fa-solid fa-exclamation-triangle"></i>');
                    }
                } else if (data.type === 'showKeyBinding') {
                    showKeyBinding(data.message);
                } else if (data.type === 'keySelected') {
                    // Show key selection without auto-hiding (waiting for confirmation)
                    showKeySelection(data.key, data.value);
                } else if (data.type === 'keyBindingComplete') {
                    if (data.success) {
                        updateKeyBindingStatus(data.key, data.value, true);
                        // Hide immediately after success
                        setTimeout(() => {
                            hideKeyBinding(); 
                        }, 200); 
                    } else {
                        updateKeyBindingStatus(null, null, false);
                        // Hide immediately after failure
                        setTimeout(() => {
                            hideKeyBinding(); 
                        }, 500); 
                    }
                } else if (data.type === 'keySelectionReset') {
                    // Reset key binding message to allow new key selection
                    const inputEl = document.getElementById('keyBindingText');
                    const cursorEl = document.getElementById('cursor');
                    
                    if (inputEl) {
                        inputEl.textContent = '';
                    }
                    if (cursorEl) {
                        cursorEl.style.display = 'inline-block';
                    }
                } else if (data.type === 'hideKeyBinding') {
                    hideKeyBinding();
                } else if (data.type === 'setHeaderImage') {
                    setHeaderImage(data.imageUrl); 
                } else if (data.type === 'showCustomNotification') {
                    showNotification(data.title || 'Notification', data.message || 'Custom message from server.', data.iconHtml);
                }
            } catch (error) {
                console.error('Error processing message from FiveM:', error);
            }
        });

    </script>
</body>
</html>